class PixCanvas : Behavior {
	function attached() {
		this.canvasWidth = 1999999;
		this.canvasHeight = 1999999; // TODO: Get correct values from the canvas instance
		this.canvasCenterX = 1000000; // Offset to the center coordinate, as the container can't be moved
		this.canvasCenterY = 1000000;

		this.on("mousedown", function(evt) {
			if (evt.buttons == 0x04) { // Middle mouse button
				this.scrolling = true;
				this.scrollingX = evt.x;
				this.scrollingY = evt.y;
				this.capture(#strict);
			}
		});

		this.on("mouseup", function(evt) {
			if (evt.buttons == 0x04) { // Middle mouse button
				this.scrolling = false;
				this.capture(false);
			}
		});

		this.on("mousemove", function(evt) {
			if (this.scrolling) {
				debug: evt.x;
				var (dx, dy) = (evt.x - this.scrollingX, evt.y - this.scrollingY);
				this.scrollTo(this.scroll(#left)-dx, this.scroll(#top)-dy);
				this.scrollingX = evt.x;
				this.scrollingY = evt.y;
			}
		});

		// TODO: Only call registerRects, if the rects have changed
		this.timer(1s, function() {
			var left = this.scroll(#left);
			var top = this.scroll(#top);
			var width = this.scroll(#width);
			var height = this.scroll(#height);

			left = left - this.canvasCenterX;
			top = top - this.canvasCenterY;

			var rects = [{
				Min: {X: left, Y: top},
				Max: {X: left+width, Y: top+height}
			}];
			view.registerRects(rects);
			return true; // keep timer running
		});

		this.$(> div).style.set({
			width: this.canvasWidth,
			height: this.canvasHeight 
		});

		//this.scrollTo(this.canvasCenterX, this.canvasCenterY, false, true);
	}

	function getChunk(x, y) { // TODO: Create function that returns chunks intersecting with a given rectangle
		for (var elem in this.$(>div)) {
			if (x >= elem.MinX && y >= elem.MinY && x < elem.MaxX && y < elem.MaxY) {
				return elem;
			}
		}
		return;
	}

	function eventInvalidateAll(event) {
		for (var elem in this.$(>div)) {
			// TODO: Show invalid chunks
		}
	}

	function InvalidateRect(event) {
		var elem = this.getChunk(event.X, event.Y);
		if (elem == null) {
			return;
		}
		// TODO: Show invalid chunks
	}

	function eventSetImage(event) {
		var (x, y) = (event.X, event.Y);
		var (width, height) = (event.Width, event.Height)

		var elem = this.getChunk(x, y);
		if (elem == null) {
			return;
		}

		function imagePainter(img) {
			var array = event.Array;
			var stride = width * 4;
			for (var iy = 0; iy < height; iy++) {
				for (var ix = 0; ix < width; ix++) {
					var offset = ix * 4 + iy*stride;
					var color = Graphics.RGBA(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
					img.colorAt(ix, iy, color); // TODO: Replace colorAt, convert image in go if possible
				}
			}
		}
		var img = new Image(width, height, Graphics.RGBA("white"), function(gfx) {});
		if (event.Array) {
			imagePainter(img);
		}
		elem.bindImage("in-memory:chunk:"+x+":"+y, img);
		elem.attributes["src"] = "in-memory:chunk:"+x+":"+y;
		elem.img = img;
	}

	function eventSetPixel(event) {
		var (x, y) = (event.X, event.Y);
		var elem = this.getChunk(x, y);
		if (elem == null || elem.img == null) {
			return;
		}
		var (cx, cy) = (x - elem.MinX, y - elem.MinY);
		elem.img.colorAt(cx, cy, Graphics.RGBA(event.R, event.G, event.B, event.A));
		elem.bindImage("in-memory:chunk:"+x+":"+y, elem.img);
		elem.attributes["src"] = "in-memory:chunk:"+x+":"+y; // TODO: Check if rebinding img and setting src is necessary
	}

	function eventSignalDownload(event) {
		var elem = this.getChunk(event.X, event.Y);
		if (elem == null) {
			return;
		}
		// TODO: Show downloading chunks

	}

	function eventChunksChange(event) {
		for (var rect in event.Remove) {
			this.getChunk(rect.Min.X, rect.Min.Y).remove();
		}

		for (var rect in event.Create) {
        	var imgElement = new Element("img");
			this.$(>div).append(imgElement);
			imgElement.style.set({
				width: rect.Max.X-rect.Min.X,
				height: rect.Max.Y-rect.Min.Y,
				left: rect.Min.X + this.canvasCenterX,
				top: rect.Min.Y + this.canvasCenterY,
				background-color: "red"
			});
			imgElement.MinX = rect.Min.X;
			imgElement.MinY = rect.Min.Y;
			imgElement.MaxX = rect.Max.X;
			imgElement.MaxY = rect.Max.Y;
		}
	}

	function eventHandler(e) {
		switch (e.Type) {
			case "InvalidateAll": {
				this.eventInvalidateAll(e);
				break;
			}
			case "InvalidateRect": {
				this.eventInvalidateRect(e);
				break;
			}
			case "SetImage": {
				this.eventSetImage(e);
				break;
			}
			case "SetPixel": {
				this.eventSetPixel(e);
				break;
			}
			case "SignalDownload": {
				this.eventSignalDownload(e);
				break;
			}
			case "ChunksChange": {
				this.eventChunksChange(e);
				break;
			}
		}
	}

	function draw(gfx) {
		var (viewOffsetX, viewOffsetY, viewZoom) = (this.viewOffsetX, this.viewOffsetY, this.viewZoom);
		
		var (left, top, right, bottom) = this.scroll(#rect);
		debug : top;
		gfx.save();
		//gfx.translate(0.5, 0.5);
		gfx.pushLayer(#inner-box);
		
		//gfx.lineCap = Graphics.CAP_ROUND;
		//gfx.lineWidth(1);
		//gfx.lineColor(color(0, 0, 0));

		for(var chunk in this.chunks) {
        	gfx.drawImage(chunk.img, chunk.x, chunk.y);
		}

		gfx.popLayer();
		gfx.restore();
	}
}